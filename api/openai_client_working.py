import requests
import time
import json
import os
from typing import Optional, Dict, Any
from config import Config

class OpenAIClient:
    def __init__(self, api_key: str = None):
        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        self.session = requests.Session()
        self.base_url = "https://api.openai.com/v1"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
    
    def _chat_completion(self, messages: list) -> str:
        """–ü—Ä—è–º–æ–π –≤—ã–∑–æ–≤ OpenAI API —Å Assistant"""
        try:
            # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–π OpenAI API
            response = self.session.post(
                f"{self.base_url}/chat/completions",
                headers=self.headers,
                json={
                    "model": "gpt-4o-mini",
                    "messages": messages,
                    "temperature": 0.7,
                    "max_tokens": 1000
                },
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                return data['choices'][0]['message']['content'].strip()
            else:
                raise Exception(f"OpenAI API error: {response.status_code} - {response.text}")
                
        except Exception as e:
            print(f"OpenAI API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
            # Fallback –Ω–∞ –ª–æ–∫–∞–ª—å–Ω—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é
            return self._generate_smart_text(messages)
    
    def _gemini_request(self, messages: list) -> str:
        """–ó–∞–ø—Ä–æ—Å –∫ Gemini API"""
        gemini_api_key = "AIzaSyDFK7vrH2hpj37cfVLSz35kjIOe5U8PHxg"
        gemini_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key={gemini_api_key}"
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º messages –≤ —Ñ–æ—Ä–º–∞—Ç Gemini
        system_prompt = ""
        user_content = ""
        
        for message in messages:
            if message["role"] == "system":
                system_prompt = message["content"]
            elif message["role"] == "user":
                user_content = message["content"]
        
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º system –∏ user –ø—Ä–æ–º–ø—Ç—ã
        full_prompt = f"{system_prompt}\n\n{user_content}" if system_prompt else user_content
        
        gemini_payload = {
            "contents": [
                {
                    "parts": [
                        {
                            "text": full_prompt
                        }
                    ]
                }
            ],
            "generationConfig": {
                "temperature": 0.7,
                "maxOutputTokens": 1000
            }
        }
        
        headers = {
            "Content-Type": "application/json"
        }
        
        resp = self.session.post(
            gemini_url,
            json=gemini_payload,
            headers=headers,
            timeout=30
        )
        
        if resp.status_code == 200:
            data = resp.json()
            if "candidates" in data and len(data["candidates"]) > 0:
                candidate = data["candidates"][0]
                if "content" in candidate and "parts" in candidate["content"]:
                    return candidate["content"]["parts"][0]["text"].strip()
        
        raise Exception(f"Gemini API error: {resp.status_code} - {resp.text}")
    
    def _generate_smart_text(self, messages: list) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —É–º–Ω—ã–π —Ç–µ–∫—Å—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –≤–∞–∫–∞–Ω—Å–∏–∏"""
        import re
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –ø—Ä–æ–º–ø—Ç–∞
        user_content = ""
        for message in messages:
            if message["role"] == "user":
                user_content = message["content"]
                break
        
        # –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –≤–∞–∫–∞–Ω—Å–∏–∏
        title = self._extract_field(user_content, r"–î–æ–ª–∂–Ω–æ—Å—Ç—å:\s*(.+)")
        payment = self._extract_field(user_content, r"–û–ø–ª–∞—Ç–∞:\s*(.+)")
        location = self._extract_field(user_content, r"–ú–µ—Å—Ç–æ–Ω–∞—Ö–æ–∂–¥–µ–Ω–∏–µ:\s*(.+)")
        object_work = self._extract_field(user_content, r"–û–±—ä–µ–∫—Ç:\s*(.+)")
        conditions = self._extract_field(user_content, r"–£—Å–ª–æ–≤–∏—è:\s*(.+)")
        
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
        templates = [
            f"""üöÄ –û—Ç–ª–∏—á–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å! 

–ü—Ä–∏–≥–ª–∞—à–∞–µ–º –Ω–∞ —Ä–∞–±–æ—Ç—É {title.lower()}! 
{f'üí∞ {payment}' if payment else 'üí∞ –î–æ—Å—Ç–æ–π–Ω–∞—è –æ–ø–ª–∞—Ç–∞'}
{f'üìç –†–∞–±–æ—Ç–∞–µ–º –≤ {location}' if location else ''}

{f'üè¢ {object_work}' if object_work else ''}
{f'‚≠ê {conditions}' if conditions else ''}

–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞—à–µ–π –∫–æ–º–∞–Ω–¥–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª–æ–≤! 
–°—Ç–∞–±–∏–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞, –¥—Ä—É–∂–Ω—ã–π –∫–æ–ª–ª–µ–∫—Ç–∏–≤, –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Ä–æ—Å—Ç–∞.

–í–∞—à–µ –±—É–¥—É—â–µ–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å–µ–≥–æ–¥–Ω—è! üåü""",

            f"""‚ú® –ú–µ—á—Ç–∞–µ—Ç–µ –æ —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç–µ?

–ú—ã –∏—â–µ–º {title.lower()} –≤ –Ω–∞—à—É –∫–æ–º–∞–Ω–¥—É!
{f'üíµ {payment}' if payment else 'üíµ –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–∞—è –∑–∞—Ä–ø–ª–∞—Ç–∞'}
{f'üåç –õ–æ–∫–∞—Ü–∏—è: {location}' if location else ''}

{f'üéØ {object_work}' if object_work else ''}
{f'‚úÖ {conditions}' if conditions else ''}

–†–∞–±–æ—Ç–∞ –º–µ—á—Ç—ã –∂–¥–µ—Ç –∏–º–µ–Ω–Ω–æ –≤–∞—Å!
–î—Ä—É–∂–Ω–∞—è –∞—Ç–º–æ—Å—Ñ–µ—Ä–∞, –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ä–æ—Å—Ç, —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å.

–û—Ç–∫—Ä–æ–π—Ç–µ –Ω–æ–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∫–∞—Ä—å–µ—Ä—ã! üìà""",

            f"""üéØ –°—É–ø–µ—Ä –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ!

–¢—Ä–µ–±—É–µ—Ç—Å—è {title.lower()}!
{f'üíé {payment}' if payment else 'üíé –ü—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–∞—è –∑–∞—Ä–ø–ª–∞—Ç–∞'}
{f'üìå {location}' if location else ''}

{f'üè≠ {object_work}' if object_work else ''}
{f'üåü {conditions}' if conditions else ''}

–≠—Ç–æ –≤–∞—à —à–∞–Ω—Å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞–±–æ—Ç—É –º–µ—á—Ç—ã!
–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞, –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã —Ä–∞–∑–≤–∏—Ç–∏—è.

–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –≥–ª–∞–≤—É –∂–∏–∑–Ω–∏! üöÄ"""
        ]
        
        # –í—ã–±–∏—Ä–∞–µ–º —à–∞–±–ª–æ–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ö–µ—à–∞ title
        template_index = hash(title) % len(templates)
        return templates[template_index].strip()
    
    def _extract_field(self, text: str, pattern: str) -> str:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –ø–æ–ª–µ –∏–∑ —Ç–µ–∫—Å—Ç–∞ –ø–æ —Ä–µ–≥—É–ª—è—Ä–Ω–æ–º—É –≤—ã—Ä–∞–∂–µ–Ω–∏—é"""
        import re
        match = re.search(pattern, text, re.IGNORECASE)
        return match.group(1).strip() if match else ""
    
    def create_assistant_message(self, assistant_id: str, content: str, 
                               max_retries: int = 3) -> Optional[Dict[Any, Any]]:
        """–°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ OpenAI Assistant API"""
        try:
            # –°–æ–∑–¥–∞–µ–º thread
            thread_response = self.session.post(
                f"{self.base_url}/threads",
                headers=self.headers,
                json={}
            )
            
            if thread_response.status_code != 200:
                raise Exception(f"Failed to create thread: {thread_response.text}")
            
            thread_id = thread_response.json()['id']
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ thread
            message_response = self.session.post(
                f"{self.base_url}/threads/{thread_id}/messages",
                headers=self.headers,
                json={
                    "role": "user",
                    "content": content
                }
            )
            
            if message_response.status_code != 200:
                raise Exception(f"Failed to add message: {message_response.text}")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º assistant
            run_response = self.session.post(
                f"{self.base_url}/threads/{thread_id}/runs",
                headers=self.headers,
                json={
                    "assistant_id": assistant_id
                }
            )
            
            if run_response.status_code != 200:
                raise Exception(f"Failed to run assistant: {run_response.text}")
            
            run_id = run_response.json()['id']
            
            # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
            for _ in range(30):  # 30 —Å–µ–∫—É–Ω–¥ –º–∞–∫—Å–∏–º—É–º
                status_response = self.session.get(
                    f"{self.base_url}/threads/{thread_id}/runs/{run_id}",
                    headers=self.headers
                )
                
                if status_response.status_code == 200:
                    status_data = status_response.json()
                    if status_data['status'] == 'completed':
                        break
                    elif status_data['status'] == 'failed':
                        raise Exception("Assistant run failed")
                time.sleep(1)
            
            # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç
            messages_response = self.session.get(
                f"{self.base_url}/threads/{thread_id}/messages",
                headers=self.headers
            )
            
            if messages_response.status_code == 200:
                messages_data = messages_response.json()
                for message in messages_data['data']:
                    if message['role'] == 'assistant':
                        return {
                            'content': message['content'][0]['text']['value'],
                            'thread_id': thread_id,
                            'run_id': run_id
                        }
            
            return None
            
        except Exception as e:
            print(f"Assistant API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
            # Fallback –Ω–∞ –æ–±—ã—á–Ω—ã–π chat completion
            messages = [
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": content}
            ]
            text = self._chat_completion(messages)
            return {'content': text, 'thread_id': None, 'run_id': None}
    
    def generate_text_for_video(self, assistant_id: str, prompt: str, context: str = "") -> str:
        full_prompt = f"""
        {prompt}
        
        –ö–æ–Ω—Ç–µ–∫—Å—Ç: {context}
        
        –í–ê–ñ–ù–û: –¢–µ–∫—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –Ω–∞ 40 —Å–µ–∫—É–Ω–¥ —á—Ç–µ–Ω–∏—è (–ø—Ä–∏–º–µ—Ä–Ω–æ 100-120 —Å–ª–æ–≤).
        –¢–µ–∫—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∂–∏–≤—ã–º, –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º –¥–ª—è –æ–∑–≤—É—á–∫–∏.
        –ò–∑–±–µ–≥–∞–π—Ç–µ —Å–ª–æ–∂–Ω—ã—Ö —Ç–µ—Ä–º–∏–Ω–æ–≤ –∏ –¥–ª–∏–Ω–Ω—ã—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π.
        """
        result = self.create_assistant_message(assistant_id, full_prompt)
        return result['content'] if result else ""
    
    def test_connection(self, assistant_id: str) -> bool:
        try:
            self._chat_completion([
                {"role": "user", "content": "say ok"}
            ])
            return True
        except Exception:
            return False
